% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazysf.R
\name{lazysf}
\alias{lazysf}
\alias{lazysf.character}
\alias{lazysf.GDALVectorConnection}
\title{Delayed (lazy) read for GDAL vector}
\usage{
lazysf(x, layer, ...)

\method{lazysf}{character}(
  x,
  layer,
  ...,
  query = NA,
  geom_format = getOption("lazysf.geom_format", "WKB"),
  dialect = getOption("lazysf.dialect", "SQLITE")
)

\method{lazysf}{GDALVectorConnection}(x, layer, ..., query = NA)
}
\arguments{
\item{x}{the data source name (file path, url, or database connection string
\itemize{
\item analogous to a GDAL dsn) or a \code{GDALVectorConnection}
}}

\item{layer}{layer name; defaults to the first layer}

\item{...}{ignored}

\item{query}{SQL query to pass in directly}

\item{geom_format}{geometry output format, passed to \code{\link[DBI:dbConnect]{DBI::dbConnect()}}}

\item{dialect}{SQL dialect, passed to \code{\link[DBI:dbConnect]{DBI::dbConnect()}}}
}
\value{
a 'tbl_GDALVectorConnection', extending 'tbl_lazy' (something that works
with dplyr verbs, and only shows a preview until you commit the result via
\code{\link[=collect]{collect()}}) see Details
}
\description{
A lazy data frame for GDAL drawings ('vector data sources'). lazysf is DBI
compatible and designed to work with dplyr. It should work with any data source
(file, url, connection string) readable by GDAL via the gdalraster package.
}
\details{
Lazy means that the usual behaviour of reading the entirety of a data source
into memory is avoided. Printing the output results in a preview query being
run and displayed (the top few rows of data).

The output of \code{lazysf()} is a 'tbl_GDALVectorConnection\verb{that extends}tbl_dbi` and
may be used with functions and workflows in the normal DBI way, see \code{\link[=GDALSQL]{GDALSQL()}} for
the lazysf DBI support.

The kind of query that may be run will depend on the type of format, see the
list on the GDAL vector drivers page. For some details see the
\href{https://hypertidy.github.io/lazysf/articles/GDALSQL.html}{GDALSQL vignette}.

When dplyr is attached the lazy data frame can be used with the usual
verbs (filter, select, distinct, mutate, transmute, arrange, left_join, pull,
collect etc.). To see the result as a SQL query rather than a data frame
preview use \code{dplyr::show_query()}.

To obtain an in memory data frame use an explicit \code{collect()}.
If the sf package is installed, \code{st_as_sf()} will collect and convert to an
sf data frame. A result may not contain a geometry column, in which case
\code{st_as_sf()} will fail.

As well as \code{collect()} it's also possible to use \code{tibble::as_tibble()} or
\code{as.data.frame()} or \code{pull()} which all force computation and retrieve the
result.
}
\examples{
## a multi-layer file
f <- system.file("extdata/multi.gpkg", package = "lazysf", mustWork = TRUE)
lazysf(f)

\donttest{
## Geopackage (an actual database, so with SELECT we must be explicit re geom-column)
nc <- system.file("extdata/nc.gpkg", package = "lazysf", mustWork = TRUE)
lazysf(nc)
lazysf(nc, query = "SELECT AREA, FIPS, geom FROM nc WHERE AREA < 0.1")
lazysf(nc, layer = "nc") |> dplyr::select(AREA, FIPS, geom) |> dplyr::filter(AREA < 0.1)

## the famous ESRI Shapefile (not an actual database)
shdb <- system.file("extdata/nc.shp", package = "lazysf", mustWork = TRUE)
shp <- lazysf(shdb)
library(dplyr)
shp |>
 filter(NAME \%LIKE\% 'A\%') |>
 mutate(abc = 1.3) |>
 select(abc, NAME, `_ogr_geometry_`) |>
 arrange(desc(NAME))
}
}
