---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(dplyr)
```

# lazysf

<!-- badges: start -->
[![CRAN status](https://www.r-pkg.org/badges/version/lazysf)](https://CRAN.R-project.org/package=lazysf)
[![](http://cranlogs.r-pkg.org/badges/last-month/lazysf?color=green)](https://cran.r-project.org/package=lazysf)
<!-- badges: end -->

lazysf provides a dplyr backend for any vector data source readable by GDAL.
It uses `gdalraster::GDALVector` to talk to GDAL and `dbplyr` for SQL
translation, giving you lazy evaluation of spatial data through familiar dplyr
verbs.

Vector data sources — files, URLs, databases, cloud storage — are accessed
through a DBI connection. Nothing is read into memory until you call
`collect()`.

## Quick start

```{r quick-start}
library(lazysf)
library(dplyr)

f <- system.file("extdata/nc.gpkg", package = "lazysf", mustWork = TRUE)
lf <- lazysf(f)
lf
```

Standard dplyr verbs generate SQL that GDAL executes:

```{r dplyr-verbs}
lf |>
  filter(AREA < 0.1) |>
  select(NAME, AREA, geom) |>
  arrange(AREA)
```

Use `show_query()` to see the SQL:

```{r show-query}
lf |>
  filter(AREA < 0.1) |>
  select(NAME, AREA, geom) |>
  arrange(AREA) |>
  show_query()
```

Use `collect()` to pull data into memory:

```{r collect}
d <- lf |>
  filter(AREA < 0.1) |>
  select(NAME, AREA, geom) |>
  collect()
d
```

## Spatial SQL (SQLITE dialect)

lazysf defaults to the SQLITE dialect, which gives you access to spatial SQL
functions. These are translated from R-style names to their SQL equivalents:

```{r spatial-sql, eval = FALSE}
lf |>
  mutate(area_m2 = st_area(geom)) |>
  filter(st_area(geom) > 0.1) |>
  mutate(srid = st_srid(geom)) |>
  collect()
```

Functions like `st_area()`, `st_srid()`, and `st_geometrytype()` work via
GDAL's built-in SQLite engine (no SpatiaLite extension needed). Functions that
operate on geometry values (like `st_astext()`, `st_intersects()`,
`st_buffer()`) require a SpatiaLite-enabled GDAL build.

## Arrow stream interface

For larger datasets, enable GDAL's columnar Arrow C stream interface for
faster data transfer:

```{r arrow, eval = FALSE}
lf <- lazysf(f, use_arrow = TRUE)
lf |> collect()
```

This uses `GDALVector$getArrowStream()` via nanoarrow — data moves from GDAL
to R in columnar batches instead of row-by-row. Requires GDAL >= 3.6.

## SQL dialects

lazysf supports two SQL dialects:

**SQLITE** (default): Full SQLite syntax including subqueries, spatial
functions, `CAST`, `GROUP BY`, `ORDER BY`. Required for dbplyr to work
properly. This is GDAL's embedded SQLite engine, available for any format.

```{r sqlite}
lazysf(f) |>
  group_by(SID74) |>
  summarise(n = n(), mean_area = mean(AREA, na.rm = TRUE)) |>
  collect()
```

**OGRSQL**: GDAL's native OGR SQL. Simpler, no subquery support, but works
for basic operations:

```{r ogrsql, eval = FALSE}
lazysf(f, dialect = "OGRSQL") |>
  filter(NAME %LIKE% "A%") |>
  collect()
```

## DBI connection

For more control, use the DBI interface directly:

```{r dbi}
con <- dbConnect(GDALSQL(), f)
con
dbListTables(con)
dbListFields(con, "nc")
DBI::dbDisconnect(con)
```

## Geometry formats

lazysf supports four geometry output formats, set via `geom_format`:

- `"WKB"` (default): Well-Known Binary, as `wk::wkb` vectors
- `"WKT"`: Well-Known Text, as `wk::wkt` vectors
- `"BBOX"`: Bounding box per feature, as `wk::rct` vectors
- `"NONE"`: No geometry (attributes only, faster for non-spatial queries)

```{r geom-format}
lazysf(f, geom_format = "WKT") |>
  select(NAME, geom) |>
  head(3) |>
  collect()
```

## Online sources

Any GDAL-readable source works — local files, URLs, cloud storage, databases:

```{r online, eval = FALSE}
## GeoJSON from URL
lazysf("https://example.com/data.geojson")

## PostgreSQL/PostGIS
lazysf("PG:host=localhost dbname=mydb user=me password=secret")

## Cloud-optimized sources via /vsicurl/
lazysf("/vsicurl/https://example.com/large.gpkg")
```

## Installation

```r
# From CRAN
install.packages("lazysf")

# Development version from r-universe
options(repos = c(
  hypertidy = "https://hypertidy.r-universe.dev",
  CRAN = "https://cloud.r-project.org"))
install.packages("lazysf")
```

## Known limitations

- **No window functions**: `slice_min()`, `slice_max()`, `row_number()` etc.
  are not supported by GDAL's SQLite engine.
- **OGRSQL dialect**: Does not support subqueries, so complex dplyr verb chains
  may fail. Use SQLITE dialect (the default) instead.
- **FID is sticky**: GDAL always includes the feature ID column in results,
  even when your SQL doesn't select it.
- **Format-dependent**: Performance and capability varies by GDAL driver. File
  formats like Shapefile and GeoPackage work well; text formats like CSV or
  GeoJSON are slower for large data.

---

## Code of Conduct

Please note that the lazysf project is released with a [Contributor Code of
Conduct](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html). By
contributing to this project, you agree to abide by its terms.
